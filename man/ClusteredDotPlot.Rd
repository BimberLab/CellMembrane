% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Analysis.R
\name{ClusteredDotPlot}
\alias{ClusteredDotPlot}
\title{ClusteredDotPlot}
\usage{
ClusteredDotPlot(
  seuratObj,
  features,
  groupFields = "ClusterNames_0.2",
  assay = "RNA",
  scaling = "column",
  layer = "data",
  forceRescaling = FALSE,
  column_km = NULL,
  row_km = NULL,
  columnTitles = NULL,
  rowTitles = NULL,
  numberColumns = TRUE,
  numberRows = TRUE,
  height = NULL,
  width = NULL,
  clusterRows = F,
  row_title_rot = 0,
  column_title_rot = 0,
  show_row_dend = NULL,
  show_column_dend = TRUE,
  row_split = NULL,
  column_split = NULL
)
}
\arguments{
\item{seuratObj}{The Seurat object that holds the data.}

\item{features}{The features to plot.}

\item{groupFields}{The metadata column that is used for grouping.}

\item{assay}{The assay to plot.}

\item{scaling}{The scaling method for the heatmap. Options are "row", "column", or none.}

\item{layer}{The layer of the Seurat object that holds the relevant expression data.}

\item{forceRescaling}{A boolean that determines if the Seurat object should be rescaled to include entries in the features vector if any are missing from the scale.data layer. This might be costly to perform locally.}

\item{column_km}{The number of k-means clusters to split the columns into. This is passed directly to ComplexHeatmap. Must be an integer or NULL.}

\item{row_km}{The number of k-means clusters to split the rows into. This is passed directly to ComplexHeatmap. Must be an integer or NULL.}

\item{columnTitles}{The column title(s) for the heatmap. Acceptable values are 1 (for a single title), NULL (for no title), or length(columnTitles) == column_km. If column_km is an integer, these will be used to label the k-means column-wise clusters. Please note that alignment of the column titles and the k means clustering will likely need manual adjustment after an initial assessment of the order of the kmeans clusters.}

\item{rowTitles}{The row title(s) for the heatmap. Acceptable values are 1 (for a single title), NULL (for no title), or length(rowTitles) == row_km. If row_km is an integer, these will be used to label the k-means row-wise clusters. Please note that alignment of the row titles and the k means clustering will likely need manual adjustment after an initial assessment of the order of the kmeans clusters.}

\item{numberColumns}{A boolean that determines if the column titles should be numbered. If columnTitles is not NULL, this will be ignored.}

\item{numberRows}{A boolean that determines if the row titles should be numbered. If rowTitles is not NULL, this will be ignored.}

\item{height}{A passthrough variable to ComplexHeatmap for the height of the heatmap.}

\item{width}{A passthrough variable to ComplexHeatmap for the width of the heatmap.}

\item{clusterRows}{A boolean that determines if the rows should be clustered.}

\item{row_title_rot}{The angle for rotation of the row titles.}

\item{column_title_rot}{The angle for rotation of the column titles.}

\item{show_row_dend}{A boolean that determines if the row dendrogram should be shown.}

\item{show_column_dend}{A boolean that determines if the column dendrogram should be shown.}

\item{row_split}{This argument accepts an integer, in which case it behaves exactly like row_km, or a vector of length equal to the features vector. This vector will be used to group features into subpanels regardless of their expression clustering.}

\item{column_split}{This argument accepts an integer, in which case it behaves exactly like column_km, or a vector of length equal to the groupFields vector. This vector will be used to group groupFields into subpanels regardless of clustering.}
}
\description{
A function that generates a clustered dot plot with a heatmap of scaled expression.
}
\examples{
\dontrun{
#set the seurat Idents for FindAllMarkers
Seurat::Idents(seuratObj) <- "ClusterNames_0.2"

markers <- Seurat::FindAllMarkers(seuratObj)

#filter markers to display the largest cluster identity markers according to average log fold change and differences in pct expression.
strong_markers <- markers[abs(markers$avg_log2FC) > 3 & abs(markers$pct.1 - markers$pct.2) > 0.25, "gene"]

dotPlot <- ClusteredDotPlot(seuratObj, features = strong_markers, groupFields = "ClusterNames_0.2", scaling = 'column')
print(dotPlot)

}
}
